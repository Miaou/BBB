Boot sequence :
- débrancher tout
- brancher la manette de XBox (drain important, ne marche pas si BBB branchée en USB seulement)
- brancher la BBB
- brancher la BBB en USB
- (optionnel) configurer le partage de connexion internet depuis Windows, script de boot sur la BBB en ssh (non fourni)
- en ssh root@192.168.7.2, lancer python3 servos.py dans libServo (les servos ne sont pas encore alimentés, c'est normal)
- lancer xboxdrv --silent (il ne faut plus quitter l'appli)
- brancher les servos (il se peut qu'ils bougent un peu)
- lancer hexapod/board.py ou ce que vous voulez


Hardware :
- utilisation des PINS :
  - dans l'idée P8_29 à P8_46, sur les fils HDMI/LCD, ce qui pousse à faire la configuration du pinmuxing de ces pins
  - MAIS, blague, il se trouve en pratique que ces fils sont aussi les fils de boot du processeur
    - cf. le manuel, Section x.y "Pin Usage Consideration"
    - les tensions dans les fils de signaux des servos suffisent à faire booter le proco n'importe comment
    - donc utiliser les positions P8_29 à P8_46 marche, sauf qu'il faut pas rebooter...
    - donc j'utilise les pins suivants :
      - impairs sont les pattes de droites, pairs celles de gauches (parce que ma BBB est à l'envers sur l'hexapod)
      - pour chaque triplet du haut vers bas : hip femur tibia (donc 11->hip, 13->femur, 15->tibia)
                    P9                                  P8
                  1 .. 2                              1 .. 2 
                  3 .. 4                              3 .. 4 
                  5 .. 6                              5 .. 6 
                  7 .. 8                              7 XX 8 
                  9 .. 10               front right   9 XX 10  front left
                 11 XX 12                            11 XX 12
   middle right  13 XX 14  middle left               13 XX 14
                 15 XX 16                rear right  15 XX 16  rear left
                 17 .. 18                            17 XX 18
                 19 .. 20                            19 .. 20
                 21 .. 22                            21 .. 22
                   [..]                                [..] 
                 45 .. 46                            45 .. 46
- configuration du pinmuxing pour dire à la BBB de rendre ces pins accessibles via GPIO
  - (obsolète pour le HDMI, mais il faut quand même faire un device tree object pour activer le PRU)
  - unload le device tree HDMI pour libérer les GPIO
    - ouvrir la partition bootable (depuis le Windows sur lequel il est branché en USB, sinon ...)
    - modifier le fichier uEnv.txt, décommenter la partie Disable HDMI
    - (reboot)
  - les mettre en mode 7 via le device tree
    - devrait se faire tout seul vu que l'HDMI est désactivé
    - vérifier que c'est bon : utiliser http://www.valvers.com/embedded-linux/beaglebone-black/step04-gpio/
  - il faut quand même refaire un device tree pour activer le PRU (cf DOC_PRU)
  - blague : il faut aussi activer le module 2 des GPIOs 
    - (il y a 4 modules GPIO séparés (32 pins par modules))
    - (en général, le module est déjà activé (parce que les pins sont utilisés ailleurs))
    - (mais pas le module GPIO2 : lol)


Contrôle plus haut niveau :
- inverse kinematics pour prédire l'angle à appliquer afin d'obtenir la position du bout de la patte voulue
  - en considérant juste le fémur et le tibia dans le plan qu'ils définissent (cf. ikLegPlane)
  - en 3D par rapport à un centre imaginaire de l'hexapod (cf ik.py, et les fichiers testIK*.py)
- regroupement des servos par jambe (finalement useless)
  - étalonnage des servos (cf. config.py) : définir leur position 0°, 180° (ils sont vraiment tous différents), et la direction.
  - cf calibXBox.py ou peut-être board, y'a le mode d'emploi dedans
- construction d'une classe hexapod, support des jambes (useless aussi)
- construction du générateur des trajectoires
- construction du mouvement de l'hexapod : en fait c'est implicite : on calcule la position des servos aux instants qui nous intéressent...

Notion de trajectoire :
- les servos sont controllés en position angulaire
- on souhaite controler à peu près les positions intermédiaires des jambes
- ce qui demande une notion de trajectoire, abcisse curviligne, ...
  - (biblio Geo3D ???)
  - trajectoires -> segments [A(xa,ya,za,ta) B(xb,yb,zb,tb)], interpolation linéaire : xc = (xb-xa)/(tb-ta)*(tc-ta)+xa
    - (idée abandonnée)
  - vérifier que tous les points de la trajectoire sont accessibles, que la vitesse des moteurs n'est pas trop forte
    - éviter que l'ik plante
    - résolution ~15ms
  - ik à la volée, alphaHip,alpha,beta pour chaque jambe (les noms sont débiles, je sais)
  - possibilité de rester mou entre deux trajectoires ?
    - (non testé)
- suivi de la trajectoire : on calcule au temps voulu
  - en pratique, on peut générer > 250 traj par sec, donc c'est mieux que la freq de rafraichissement des servos (50Hz)
  - donc on s'en fout


Mouvements de l'hexapod
- 6 DOF: avance/recul, latéral gche/dte, hauteur sol, bascule avant/arrière, bascule côtés, rotation sur lui même
  - sachant que le tangage et le roulis ne seront pas précis (distance du point de contact des pattes au centre du robot) ni très utile...
- combiner :
  - 3 jambes à terre, qui vont à l'inverse du mouvement de l'hexa
  - 3 jambes en l'air, qui vont dans le même sens que l'hexa
  - au moment où les jambes s'inversent, elles ont le même avancement (neutre)
  - donc combiner :
    - le mouvement souhaité de l'hexa
      - combinaison linéaire des 3D "infinis" avance, latéral (strafe), lacet (yaw)
      - combinaison linéaire des 3D "limités" tangage (pitch), roulis (roll), hauteur
    - le cycle de marche
- en pratique : calcul d'une trajectoire combinant les mouvements intuitifs "infinis" : rotation sur z et translationsx,y
  - implémenté dans trajectory.py
  - Al-Kashi, formules sur le papier, pas vraiment détaillé dans trajectory.py
  - idée qu'on a un rayon accessible par la patte autour d'un point optimal (sweet spot "S")
  - on trouve "S" et le rayon "r" pour un "z" donné de manière expérimentale,
  - ainsi que la hauteur "h" à laquelle la patte peut remonter au point neutre
  - tout ça dans findSR.py (là bas pour changer le système qui attribue S,r,h en fonction de z)

  
Interface utilisateur
- textuelle, basée sur curses
- contrôles au pad de XBox, probablement pas trop dur à adapter au clavier
- notion de "mode de fonctionnement"
  - une seule User Interface regroupe différentes fonctions
  - but : avoir une seule application commune pour la marche, la calibration, un mode pose, 
    - et surtout les transitions entre modes (qui peuvent provoquer des mouvements brusques)
    - marche : croisée 3-3, mais pas les pattes arrières en retard (comme chez un insecte), car ça devient vraiment encore moins naturel de piloter...
    - calibration : différentes positions de pattes pour régler les servos
    - pose : pouvoir changer chaque servo à la manette, et obtenir une pose, sauvegarder les poses
    - réglages : réglages des Vmax, de S, r, h, deltaU, mode arrière train décalé
    - animator : pouvoir faire des keyframes, rejouer une animation, lire un xml, mais régler les pattes en mode poupée
  - gérer les transitions entre modes (et l'extinction non brutale)
    - (pas fait)



